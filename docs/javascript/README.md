## JavaScript

### 자바스크립트 코드는 어떻게 실행될까?

자바스크립트 엔진은 코드를 실행하기 위해 다음 세 단계를 거친다.

1. 파싱
2. 컴파일
3. 실행

---

## 파싱

파싱 과정은 코드를 실행하기 전에 문법을 분석하고 구조화하는 단계이다.

### 토큰화

코드 문자열을 의미 있는 최소 단위인 토큰(token)으로 분해한다.

ex)

```js
const a = 10;

// 위 코드는 다음과 같은 토큰으로 분리된다.
const, a, =, 10, ;
```

### 1. AST 생성

토큰을 기반으로 AST(=추상 구문 트리)를 생성한다.
AST는 코드의 문법적 구조를 트리 형태로 표현한 자료 구조이며,
컴파일 단계에서 필요한 핵심 정보가 된다.

### 2. 컴파일

AST가 생성된 후, 자바스크립트 엔진은 이를 바이트코드로 변환한다.

우리가 작성한 코드를 컴퓨터가 이해할 수 있도록 한 코드가 **바이트 코드** 이다.

### 3. 실행

컴파일된 바이트코드는 실행 단계에서 처리된다.

이때 실행 컨텍스트가 생성되며 다음과 같은 정보가 관리된다.

- 변수

- 함수

- this

- 스코프

- 객체 상태 등

실행 컨텍스트는 콜 스택(Call Stack)에 쌓이고 제거되면서 프로그램이 진행된다.

- 함수 호출 → 실행 컨텍스트 push

- 함수 종료 → 실행 컨텍스트 pop

## 스코프

스코프는 변수가 유효한 범위를 의미한다.

### 전역 스코프

프로그램 전체에서 접근 가능한 영역이다.

### 지역 스코프

함수 또는 블록 내부에서만 접근 가능한 영역이다.

let, const는 블록 스코프를 따른다.

### 스코프 체인

자바스크립트 엔진은 변수를 탐색할 때 다음 순서로 찾는다.

- 현재 스코프

- 상위 스코프

- 전역 스코프

이 **구조를 스코프 체인**이라고 한다.

## 클로저

클로저란 "둘러싸여진 상태의 참조"와 함께 다발로 묶여진 함수의 콤비네이션이다.

바꿔말하면 클로저는 내부 함수로부터 외부함수의 접근권한을 준다.

**클로저는 함수 생성 시점에 언제나 생긴다.**

클로저는 **함수가 생성될 당시의 외부 스코프를 기억하고, 해당 함수가 실행될 때 그 스코프에 접근할 수 있게 하는 메커니즘** 이다.

즉, 내부 함수가 외부 함수의 변수에 접근할 수 있도록 해주는 기능이다.

클로저는 함수가 생성되는 순간 항상 만들어진다.

```TSX
function outer() {
let count = 0;

return function inner() {
count++;
console.log(count);
};
}

const fn = outer();
fn(); // 1
fn(); // 2
```

outer 함수는 종료되었지만 count는 내부 함수가 계속 참조할 수 있다.

## 프로토타입 / 클래스

자바스크립트는 **프로토타입 기반 언어**이다.

모든 객체는 **프로토타입이라는 내부 링크를 가지고 있으며 이를 통해 상속이 이루어진다.**

## 프로토타입 체인

객체에서 속성을 찾을 때,

- 해당 객체

- 그 객체의 프로토타입

- 상위 프로토타입

- Object.prototype

순으로 탐색하는 구조를 말한다.

### 클래스(Class)

ES6의 class 문법은 **프로토타입 기반 상속**을 사용하기 쉽게 만든 문법이다.

```TSX
class Person {
constructor(name) {
this.name = name;
}

sayHi() {
console.log(`I'm ${this.name}`);
}
}
```

내부적으로는 여전히 프로토타입을 기반으로 동작한다.

### this 바인딩

자바스크립트에서 **this는 함수 호출 방식에 따라 값이 결정**된다.

1. 기본 바인딩

전역 영역에서의 this는 전역 객체를 의미한다.

2. 암시적 바인딩

객체의 메서드로 호출될 경우, this는 해당 객체를 가리킨다.

`obj.fn(); // this === obj`
