## docker

[docker란?](#docker)

[왜 docker를 사용하는가](#왜-docker를-사용하는가)

[docker file](#docker-file)

[docker image](#docker-image)

[docker container](#docker-container)

[docker volume](#docker-volume)

[docker compose](#docker-compose)

[react 프로젝트에 docker 적용하기](#react-프로젝트에-docker-적용하기)

[기타](#기타)

---

## Docker란?

도커란 **"서비스를 구축, 테스트 및 배포할 수 있는 컨테이너 기반 오픈소스 가상화 플랫폼"** 이다.

쉽게 말해, 도커는 앱을 실행할 때 **필요한 환경(OS, 라이브러리 등)을 상자(=컨테이너) 안에 담아**서, 어디서나 동일하게 실행되도록 도와주는 도구다.

VM과 달리 도커는 베이스 환경의 OS를 공유하면서 필요한 프로세스와 라이브러리 등만 격리하는 방식이다.

**구성**

도커는 아래와 같이 구성된다.

**docker file, docker image, docker container, docker volume**

위의 키워들을 쉽게 비유하면 이렇게 표현할 수 있다.

> 📜 **햄버거 레시피 (=docker file)** 를 보고 🍔 **햄버거 (=docker image)** 를 만들어서 🤵🏻‍♂️ **고객에게 제공 (=docker container)** 한다. 📦 **재료를 안전하게 보관(=docker volume)** 할 수도 있다.

자세한 내용은 각 키워드에서 볼 수 있다.

**관련 시스템**

관련 시스템은 아래와 같이 구성된다.

**docker desktop, docker hub**

Docker Desktop은 내 PC에서 **도커를 쉽게 관리**할 수 있는 GUI/CLI 도구다.

[Docker Desktop](https://docs.docker.com/desktop/setup/install/windows-install/)

Docker Hub는 도커 이미지를 공유하고 내려받을 수 있는 공간으로 **github**과 유사하다. 리포지토리에서 내려받아 사용하는 방식이다.

[Docker Hub](https://hub.docker.com/)

## 왜 docker를 사용하는가

1. 개발 환경 통일

아래와 같은 경험을 겪어본 적 있는가? 😱

**case 1)** 여러사람과 협업을 하는 과정에서 **각 개발자마다 OS, 라이브러리 버전 등 환경이 다르다면**, 동일한 환경을 맞추기 위해 모두가 일일이 버전을 확인하고 설치해야 한다.

**case 2)** 로컬에서 개발 후 서버에 배포할 때, 개발 환경과 서버 환경이 다르면 **"컴에서 분명 됐는데 서버에서 안돼.."** 라는 상황이 발생한다.

도커는 운영체제, 런타임, 라이브러리, 환경변수 등 코드 실행에 필요한 것을 모두 정의가 가능하다.

😎 <span style="color: #1B9EC8">이에, 누가 코드를 받아도 도커만 사용하면 **동일환 환경**에서 코드가 돌아간다!</span>

2. 배포 자동화 및 효율성

하나의 서버에서 여러 기능(웹 (nginx), API (spring boot), 캐시 (redis)등) 을 동시에 실행해야 할 때,
기능별로 컨테이너를 나눠 실행하면 관리와 배포가 훨씬 편리하다.

이때, 🐳 도커를 사용하면 **하나의 서버에 여러 도커 컨테이너를 실행하여 여러 서비스를 동시에 배포할 수 있다!**

ci/cd와 연동하면 테스트 → 빌드 → 배포까지 자동화도 가능하다.

또한 하나의 컨테이너에서 모든 것을 하는 게 아닌 아래와 같이 기능별로 컨테이너를 나눠 갖다 쓰면 **종속되지 않기에 문제 발생 시 에러를 잡기 쉽다.**

```tsx
ex)
- auth 컨테이너 : 로그인, 회원가입 등 인증 관련 기능
- user 컨테이너 : 사용자 프로필, 계정 관리
- post 컨테이너 : 게시물, 글 작성/조회 기능
```

3. 성능

VM보다 훨씬 가볍고 빠르게 실행이 가능하다.

호스트 OS 커널을 공유하기 때문에 불필요한 리소스를 사용하지 않아 효율적이다.

4. 격리된 환경

case 1) 새로운 라이브러리나 DB 버전 등 테스트를 하고 싶을 때

case 2) 하나의 컨테이너에서 문제가 생겼을 때

도커는 각 컨테이너를 격리된 환경으로 실행하므로, 하나의 컨테이너에서 발생한 문제가 다른 컨테이너에 영향을 절대 주지 않는다. 또한 컨테이너 안에서 마음껏 테스트 후 삭제하기만 하면 원래 환경이 그대로 유지된다!

이러한 이유로 도커는 🔥 **2025 기준 개발자들이 가장 좋아하는 기술이자 현업에서도 대부분 쓰인다!**

> 그러면 docker의 단점이나 docker의 대체제는 없을까? 🤔

docker와 같은 기술은 Podman, CRI-O, LXC 등이 존재한다.

대표적으로, Podman은 기본적으로 루트 권한 없이 컨테이너 실행 가능해 도커보다 보안성이 높다.

또한 도커는 항상 백그라운드 Docker 데몬이 필요하지만, Podman은 데몬 없이 CLI만으로 컨테이너 실행 가능하다는 장점을 갖고 있다.

최근 일부 Docker 플랜이 유료화되면서, 기존에 무료로 사용하던 개발자 및 기업에서 불만이 생기고 있기도 하다.

Podman은 Docker와 거의 동일한 기능 및 장점 또한 가지고 있지만

- 상대적으로 커뮤니티 규모가 작고

- 사용 사례가 제한적이기에 어떠한 문제점이 있을 지 모른다.

이에 Docker만큼 안정적이라고 보기는 어렵다.

하지만 Docker는 광범위한 커뮤니티, 수많은 운영 사례, 풍부한 생태계를 가지고 있어서 가지고 있는 단점들도 해결할 거기에 다들 사용하는 것 같다.

그러나 언제 docker를 대체할 수 있는 기술이 나올지 모르니 항상 관심있고 기술을 고를 때 "왜?" 이라는 시선을 가져야한다.

## docker file

Dockerfile은 **컨테이너 이미지를 만들기 위한 설계도** 다.

이미지를 만들려면 Dockerfile이 필요한데 그 이미지를 어떻게 만들지에 관한 문서이다.

"이 이미지를 만들 때 이 OS를 쓰고, 이 파일을 복사하고, 이 명령을 실행해" 라고 순서대로 기록해둔 파일이기에 누가 만들어도 같은 이미지가 나오게 된다.

## docker image

Docker Image는 Dockerfile을 바탕으로 만들어진 실행 가능한 환경의 완성본이다.

쉽게 말해 Image = 완성된 햄버거 이며 만들어지면 더이상 수정하지 않는다. (불변성)

또한, 특정 이미지를 어디로 옮겨도 그대로 실행된다.

## docker container

Docker Container는 이미지를 기반으로 만들어진, 독립적이고 격리된 실행환경을 의미한다.

즉, 컨테이너는 **이미지를 실행한 상태** 이다.

컨테이너는 서로 격리되어 있기에 한 컨테이너가 죽거나 문제가 생겨도 다른 서비스에 영향을 주지 않는다.

## docker volume

볼륨은 컨테이너 안의 **데이터를 안전하게 저장하고 공유**할 때 사용한다.

컨테이너를 삭제하면 안에 있는 내용도 모두 사라지는데, volume에 저장된 데이터는 그대로 남게됩니다.

여러 컨테이너가 같은 volume을 공유할 수 있기에 외부 저장 공간(ex 공용냉장고 같은 느낌)이라 생각하면 된다.

> 즉, Docker Volume은 컨테이너 밖에서 데이터를 안전하게 보관하고, 필요하면 여러 컨테이너가 공유할 수 있는 외부 저장 공간이다.

## docker compose

도커를 사용하다보면 아래와 같은 생각이 든다.

**"😫 여러 컨테이너 분리해서 사용하는 건 좋은데 이걸 하나하나 관리하는 게 불편해.."**

이를 위해 docker compose가 나오게 되었다.

컴포즈는 여러개의 컨테이너를 단일 명령어로 실행하고 중지하며 여러개의 컨테이너를 **일괄적으로 관리** 할 수 있다.

즉, docker는 애플리케이션을 컨테이너라는 격리된 환경에서 실행할 수 있게 하는 도구고 **docker compose는 다중 컨테이너를 한 번에 정의하고 실행하기 위한 도구** 다.

컴포즈에서 아래와 같은 기능을 제공한다.

1. 여러 컨테이너 일괄 관리

`docker compose up` 명령어로 여러 컨테이너가 동시에 실행된다.

환경 변수, 네트워크 설정 등을 한 파일에서 관리할 수도 있다.

2. 컨테이너 실행 순서 설정

특정 컨테이너가 먼저 실행된 후 다음 컨테이너가 실행되어야 할 수 있다.

이에 “DB가 먼저 켜지고 → 서버가 켜지고 → 프론트가 켜지는” 식의 순서를 지정할 수 있다.

## react 프로젝트에 docker 적용하기

위에서 말한 내용을 실제 react 프로젝트에 적용하였다.

**구성**

```tsx
mirero-ojt
├── Dockerfile.dev
├── Dockerfile.prod
├── docker-compose.yaml   // 공통 설정
├── docker-compose.dev.yaml
└── docker-compose.prod.yaml
```

dev와 prod 환경을 분리하였다.

각각의 목적에 따라 분리하였고 주 차이점은 아래와 같다.

dev에서 node_modules는 컨테이너 내부에서 관리하고 소스 변경 시 브라우저 바로 반영하도록 핫리로드를 지원했다.

prod에서는 healthcheck로 서비스 정상 여부 체크하며 불필요한 용량을 제거하였다.

docker-compose.yaml에서는 dev와 prod에서 공통으로 사용하는 설정을 배치하였다.

서비스 이름, restart, 로그 관련해서 설정해두었으며 공통 네트워크, 공통 환경변수 등도 정의할 수 있을 것 같다.

```tsx
// dev
docker-compose -f docker-compose.yaml -f docker-compose-dev.yaml up --build

// prod
docker-compose -f docker-compose.yaml -f docker-compose-prod.yaml up --build
```

## 기타

### compose version

2024년 이후 공식적으로 version 표기를 권장하지 않는다. (사용은 가능)

Docker Compose가 version 필드를 생략해도 자동으로 최신 스펙을 사용한다.

### HEALTHCHECK

HEALTHCHECK를 통해 서비스가 정상적으로 작동중인지, 주기적으로 확인할 수 있다.

### 핫리로드

코드를 수정하면 개발자가 수동으로 새로고침할 필요 없이 자동으로 변경 사항을 반영해주는 기능이다

도커에서 컨테이너와 호스트 간 파일 변경 감지가 잘 안 될 수도 있기에 `CHOKIDAR_USEPOLLING=true`를 설정해 핫리로드를 안정적으로 작동시킬 수 있다.

### 이미지 경량화

why? 더 빠른 빌드, 배포, 실행을 위해 시행한다. 네트워크 대역폭을 절약하고 보안성을 높일 수 있다는 특징이 있다.

- 최소 베이스 이미지 사용

경량 베이스 이미지를 사용하는 것이 좋다 (Alpine Linux)

why? 일반적인 ubuntu 등의 베이스 이미지는 수백 MB이지만 alpine은 약 5MB이다.

- 불필요한 파일 제거

도커 이미지에 불필요한 파일을 포함시키지 않도록 해야한다.

- 이미지 압축

빌드 후에 이미지를 압축하여 이미지의 크기를 줄인다.

```tsx
docker image prune -f
```

- 필요한 파일만 복사

코드 파일을 복사할 때 전체 폴더를 복사하지 말고 필요한 파일만 선택적으로 복사한다.

### yaml

Yaml Ain't Markup Language = Yaml은 마크업 언어가 아니다

마크업이 아니라 데이터가 중심이라는 것을 보여주기 위해 위와 같은 명칭으로 정의했다고 한다.

#### yml VS yaml

두 확장자 모두 해석 및 구문이 동일하다.

그러나 과거 windows에서 파일 확장자가 세글자로 제한되는 특성이 있어 yml이 나오게 되었다. (.html도 htm이었음) 현재는 이와같은 제한사항이 없기에 둘 중 아무거나 사용하면 된다.
