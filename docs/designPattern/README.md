## 디자인 패턴

### 디자인 패턴이란?

디자인 패턴이란, 개발하면서 반복되는 문제 상황들을 어떻게 해결할 것인가에 대한 최적화된 해결 방안이다.

<br />

### 왜 디자인 패턴을 알아야하는가?

디자인 패턴을 알지 않더라도 개발을 하는 것이 불가능한 건 아니다. 또한 나도 모르게 일부 패턴들을 구현하고 있을 수도 있다.

그럼에도 불구하고, 디자인 패턴을 왜 알아야 할까?

먼저, 디자인 패턴은 소프트웨어 디자인의 일반적인 문제들에 대해 시도되고 검증된 해결책을 모은 것이기에 많은 종류의 문제를 만났을 때 효과적으로 해결할 수 있다.

또한 팀원들과 협업할 때 "우리 아토믹 패턴으로 해요"라고 하면 처음부터 어떻게 할 건지 정하지 않더라도 설계의도 및 방법을 이해하고 더 효율적으로 적용할 수 있을 것이다.

**즉, 디자인 패턴을 통해 시간과 노력, 시행착오를 줄일 수 있고 코드에 관련해서 더 큰 그림의 시선으로 바라보고 적용할 수 있다.**

이에 프로젝트에 맞는 디자인 패턴을 선정하고 활용하는 것이 핵심이다.

<br />

### 디자인 패턴 종류

디자인 패턴은 의도와 목적에 띠라 분류할 수 있다.

크게 **생성패턴, 구조패턴, 행동패턴**으로 분류할 수 있다.

생성패턴은 기존 코드의 유연성과 재사용을 증가시키는 다양한 객체 생성 매커니즘을 제공한다.

구조패턴은 객체와 클래스 구조를 유연하고 효율적으로 유지하면서 더 큰 구조로 조립하는 방법이다.

헹동패턴은 객체와 클래스들이 상호작용하는 방법과 역할을 분담하는 방법을 다루는 패턴이다.

<br />

### 생성패턴

### 싱글톤 패턴

특정 클래스에 **객체가 하나만 만들어지도록** 해주는 패턴이다.

싱글톤 인스턴스는 **전역에서 공유**되기 때문에 전역 상태를 관리하기에 적합하다.

**왜 싱글톤 패턴이 나오게 되었을까?**

앱 전체에서 사용하는 로그 기록을 여러 개로 분리한다면, 파일이 깨지거나 중복 로그가 발생하고 순서가 뒤죽박죽이 될 수 있어서 로그 기록은 하나가 전체를 관리하는 것이 더 효율적일 것이다.

또한, db 연결 시 여러 절차를 거치게 되는데 이를 여러 개에서 진행한다면 프로그램이 느려지고 과부하가 생기게 될 것이다.

즉,

전역에서 하나만 존재해야 할 기능을 안전하게 관리하기 위해.

생성 비용이 큰 객체를 매번 만들지 않고 성능을 최적화하기 위해.

시스템 전체의 일관성 있는 상태를 유지하기 위해.

싱글톤 패턴을 사용한다!

<br />


**장점**

인스턴스를 하나만 만들 수 있기에 메모리 공간을 절약할 수 있다.

전역 상태를 공유하기 때문에 접근하기 유용하다.

**단점**

인스턴스를 하나만 만들 수 있는 것이 단점이 된다.

여러 클래스가 단 하나의 인스턴스에 의존하기에 결합도가 높아지며 단일 책임의 원칙을 위반한다고 할 수 있다.

또한, 테스트를 할 때 이전 테스트에서 만들어진 인스턴스로 테스트를 진행해야해 하나의 테스트가 끝나면 인스턴스를 초기화해줘야 한다는 불편함이 있다.

전역에서 접근할 수 있기 때문에 언제 어떻게 값이 바뀌었는 지 추적하기 어렵고 디버깅이 복잡해질 수 있다.

<br />

### 프로토타입 패턴

프로토타입 패턴은 같은 타입의 여러 객체들이 프로퍼티를 공유할 때 사용한다.

쉽게 말하자면, 보통 실제 제품을 만들기에 앞서 테스트를 위해 샘플 제품을 만드는데 이 샘플을 프로토타입이라고 한다.

즉, 프로토타입 패턴은 원본 객체를 새로운 객체에 복사(clone)해 필요에 따라 수정하는 방법이다.

새로 만들지 않고 이미 있는 객체를 복사해 사용하는 패턴이다.

**왜 프로토타입 패턴이 나오게 되었을까?**

매번 객체를 새로 만들면 비용(시간 및 자원)이 크다. 많은 연산을 거쳐야 하거나, 복잡한 설정들이 있을 경우 매번 다시 만드려면 생각만해도 비효율적이다. 😫

몬스터 100마리를 만들 때 100마리를 하나하나 정의하고 설정할 것인가?

그렇지 않고, 기본 몬스터 1마리를 만들고 나머지는 복사(clone)하여 사용하는 것이 효율적이다.

(*여기서 복사한 객체들은 독립적이라는 것이 특징이다.)

**즉, 프로토타입 패턴은 이미 준비된 객체를 하나 만들어두고, 복사해서 사용하면 방법이다!**

<br />

**장점**

객체 생성 비용을 줄일 수 있다.

구현이 단순하고 비교적 쉽다.

**단점**

복사를 할 때 객체마다 복사할 내용, 복사하면 안되는 내용이 있을 수 있다. 이에 구분을 하면서 clone을 해야하기에 실수하기 쉽다.

또한, 원본 객체가 잘못되면 clone한 객체 모두 잘못된 상태를 물려받게 될 것이다.

<br />

### 팩토리 패턴

팩토리 패턴은 객체 생성을 공장 (팩토리) 클래스로 캡슐화 처리하여 대신 생성하게 하는 패턴이다.

쉽게 말해, 객체를 직접 만들지 않고 공장에 맡긴다는 것이다.

객체 종류가 여러개거나, 속성이 많아져 객체 생성 방식이 복잡하다면, 공장(팩토리)에 생성책임을 맡기는 것이다.

```tsx
// 팩토리 패턴
function Mirero(type){
if (type === "슬희") {
return new Mirero("프론트", 2025, "DM");
} else if (type === "성호") {
return new Mirero("프론트", 2025, "DMS/TF");
} else {
return new Mirero("홍길동", 1994, "");
}
}

// 실제 사용
const types = ["슬희", "성호"];

const mireros = types.map(type => Mirero(type));
```

위의 예시와 같이 객체 생성에 대한 책임이 공장 (팩토리)에 집중되어있고 새로운 타입을 추가할 때에는 팩토리 함수만 수정하면 된다!

<br />

**장점**

객체 생성을 한 곳에서 하기 때문에 관리가 쉽고 유연성이 높다.

또한 코드 중복이 감소되어 유지보수가 쉽고 실제 사용 시에도 단순히 호출만 하면 된다는 장점이 있다.

**단점**

조건이 복잡해지면 if문이나 스위치문이 복잡해지고 오히려 유지보수가 어려울 수 있으며 조건문 처리로 인해 느려질 수 있다.

<br />

### 구조패턴

### 플라이웨이트 패턴

플라이웨이트 **패턴은 재사용 가능한 객체를 공유시켜 메모리를 최소하는 패턴**이다.

즉, 공유 가능한 부분을 만들어서 재사용하고 객체마다 다른 데이터만 따로 붙여 메모리를 아낀다. 이에 경량패턴이라고도 불린다.

공통 데이터는 하나만 만들고, 각 객체마다 다른 데이터만 따로 저장해서 메모리를 절약하는 패턴이다.

객체의 공통데이터는 공유하고 개별 데이터만 따로 관리한다는 점이 핵심이다.

프로토타입 패턴과 재사용하는 것이 비슷하지만 프로토타입 패턴은 재사용 시 독립된 객체로 보고 데이터를 공유하지 않는다.

<br />

**장점**

메모리 절약에 효과적이며 많은 수의 객체 생성 시 성능이 최적화된다.

**단점**

코드 복잡도가 증가하며 공유와 비공유 상태를 분리해야하기에 설계가 어려울 수 있다.

<br />

### 프록시 패턴

프록시 패턴은 대상 원본 객체를 대신 처리하게 함으로써 로직의 흐름을 제어하는 패턴이다.

프록시는 **"대리인"**이라는 의미를 담고 있는데, 즉 누군가에게 어떤 일을 대신 시킨다는 것이다.

클라이언트가 실제 객체를 직접 다루지 않고 프록시 (대리인) 을 통해 접근한다.

즉, **프록시는 객체 기능을 그대로 제공하면서 추가 로직을 중간에서 수행할 수 있는 대리인 역할**을 한다.

```tsx

const greetingNewcomer = (name) => {
return <span>${name}님이 미래로에 입사했어요</span>
}


// 프록시 패턴
function greetingProxy(name){

    if (name === 2025이전 입사자) return <span>2025년 입사자가 아니에요</span>;
    if (!name) return <span>이름을 입력해주세요</span>;
    return greeingNewcomer(name)

}

function Main(){
const [name, setName] = useState("");
const [message, setMessage] = useState("");
const handleClick = () => {
const result = greetingNewcomer(name);
setMessage(result)
}

return <main>
...
<span>{message}</span>
<button onClick={handleclick}>누가 입사했을까용</button>
</main>
}
```

위의 예제처럼 프록시 패턴은 중간에서 추가 기능을 수행하면서 원본을 안전하게 제어하는 것이 목적이다.

<br />

**장점**

클라이언트가 직접 원본 객체에 접근하지 않아도 제어가 가능하며 원본 객체를 수정하지 않아도 기능 확장이 가능하므로 유지보수에 유리하다.

**단점**

단순한 경우 오히려 불필요한 리소스가 될 수 있다. (like 위의 예제처럼..)

프록시가 여러 단계로 있을 경우 성능이 떨어질 수 있고 디버깅 시에 원본과 프록시를 모두 관리해야한다는 것이 단점이다.

<br />

#### 행동패턴

### 커멘드 패턴

커멘드 패턴은 **요청을 객체로 캡슐화하여 호출자, 수행자를 분리하고 요청을 저장하거나 취소할 수 있게 하는 패턴**이다.

예를 들어, TV를 키고 싶을 때 전원버튼을 누르면 리모컨이 TV를 제어한다. 이때 전원버튼을 커멘드 객체라 할 수 있다.

TV를 켜라 or 꺼라 에 대한 행동을 캡슐한 것이고, 누가 어떻게 호출할지는 리모컨이 관리하는 것이다.

즉, 앞서 말했듯이 호출자와 수행자를 분리한다 했기에 예제에서는 TV = 수행자, 리모컨 = 호출자, 전원버튼 = 커멘드 라 할 수 있다.

```tsx
const TV = {
  on: () => console.log("TV 켜짐"),
  off: () => console.log("TV 꺼짐"),
};

const tvOnCommand = {
  execute: () => TV.on(),
  undo: () => TV.off(),
};


const tvOffCommand = {
  execute: () => TV.off(),
  undo: () => TV.on(),
};
```

<br />

**장점**

클라이언트는 커멘드 객체만 호출하면 되고 실제 동작은 수행자가 처리하기 때문에 유연성이 증가한다.

기능 확장에 유리하고 로깅이나 요청 저장등이 가능하다.

**단점**

단순한 기능일 경우 커멘드, 호출자, 수행자를 나누는 게 오히려 코드도 많아지고 구조가 복잡해질 수 있다. (소규모 프로젝트에서는 과할 수 있음)

<br />

### 옵저버패턴

옵저버 (관찰자)들이 관찰하고 있는 대상자의 상태가 변화가 있을 때마다 대상자는 각 관찰자들에게 통지하고 관찰자들은 알림을 받아 조치를 취하는 행동 패턴이다.

예를 들어, 유튜버가 영상을 올리면 여러명의 구독자들은 모두 "영상이 올라왔습니다." 라는 알람을 받게 된다.

이 구조에서 구독자들은 해당 채널을 구독함으로써 채널에 변화(영상이나 공지가 올라옴)가 생기게 되면 바로 알람을 받아 조치를 취한다.

즉, **옵저버 패턴은 한 객체의 상태가 변경되면 그 변화를 의존하는 다른 객체들이 자동으로 통지를 받게 된다!**

채팅, 주식, 알람 등 실시간 반응이 필요한 서비스에 적합하다.

<br />

**장점**

상태 변화에 자동으로 반응해 UI동기화에 유리하다.

**단점**

상태 변화가 전파되므로 디버깅이 어렵다. 또한 상태변화가 잦으면 성능이 저하되고 무한루프가 발생할 수 있다.

<br />

### 기타

- 디자인 패턴 관련 자료 https://patterns-dev-kr.github.io/design-patterns/mediator-middleware-pattern/